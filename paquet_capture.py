from scapy.all import sniff, IP, TCP, UDP, ICMP, ARP, IPv6, DNS
import pandas as pd
from datetime import datetime
import signal
import sys
import os

# Define the CSV file name where data will be saved
csv_filename = 'network_packets.csv'

# Dictionary to track the start times of TCP connections (by IP and port)
tcp_connections = {}
http_methods_count = {}
tcp_syn_times = {}
tcp_synack_times = {}

packet_counts = {}

def initialize_packet_info():
    return {
        'srcip': 'N/A',
        'sport': 'N/A',
        'dstip': 'N/A',
        'dsport': 'N/A',
        'proto': 'N/A',
        'state': 'N/A',
        'dur': 0.0,
        'sbytes': 0,
        'dbytes': 0,
        'Spkts': 0,
        'Dpkts': 0,
        'swin': 'N/A',
        'dwin': 'N/A',
        'tcprtt': 'N/A',
        'synack': 'N/A',
        'ackdat': 'N/A',
        'ct_flw_http_mthd': 'N/A',
    }

# Function to write data to the CSV file
def write_to_csv(data):
    df = pd.DataFrame(data)
    if not os.path.isfile(csv_filename):
        # If the file does not exist, add the header
        df.to_csv(csv_filename, index=False)
    else:
        # If the file already exists, add data without the header
        df.to_csv(csv_filename, index=False, mode='a', header=False)

# Define the packet processing function
def handle_packet(packet):
    try:
        packet_info = initialize_packet_info()

        # Protocol (in number)
        if IP in packet:
            packet_info['proto'] = packet[IP].sprintf("%IP.proto%")
        elif IPv6 in packet:
            packet_info['proto'] = packet[IPv6].sprintf("%IPv6.nh%")

        # IP addresses and ports
        if IP in packet:
            packet_info['srcip'] = packet[IP].src
            packet_info['dstip'] = packet[IP].dst
        elif IPv6 in packet:
            packet_info['srcip'] = packet[IPv6].src
            packet_info['dstip'] = packet[IPv6].dst

        if TCP in packet:
            packet_info['sport'] = packet[TCP].sport
            packet_info['dsport'] = packet[TCP].dport
            packet_info['swin'] = packet[TCP].window
            packet_info['state'] = packet.sprintf("%TCP.flags%")

            conn_key = (
                packet_info['srcip'],
                packet_info['sport'],
                packet_info['dstip'],
                packet_info['dsport'],
            )

            if 'S' in packet_info['state'] and not 'A' in packet_info['state']:  # It's a SYN packet
                tcp_syn_times[conn_key] = datetime.now()
                packet_info['tcprtt'] = 'N/A'  # RTT cannot be calculated with SYN only

            elif 'S' in packet_info['state'] and 'A' in packet_info['state']:  # It's a SYN-ACK packet
                tcp_synack_times[conn_key] = datetime.now()
                packet_info['tcprtt'] = 'N/A'  # RTT cannot be calculated yet

            elif 'A' in packet_info['state']:
                # Check if it's a response to a SYN packet
                if conn_key in tcp_syn_times:
                    syn_time = tcp_syn_times.pop(conn_key)
                    if conn_key in tcp_synack_times:
                        synack_time = tcp_synack_times.pop(conn_key)
                        synack = (synack_time - syn_time).total_seconds()
                        ackdat = (datetime.now() - synack_time).total_seconds()
                        packet_info['tcprtt'] = synack + ackdat
                        packet_info['synack'] = synack
                        packet_info['ackdat'] = ackdat
                    else:
                        packet_info['tcprtt'] = (datetime.now() - syn_time).total_seconds()
                else:
                    packet_info['tcprtt'] = 'N/A'

        if UDP in packet:
            packet_info['proto'] = 'UDP'  # Add support for the UDP protocol
            packet_info['sport'] = packet[UDP].sport
            packet_info['dsport'] = packet[UDP].dport

        # ARP Protocol
        if ARP in packet:
            packet_info['proto'] = 'ARP'
        elif DNS in packet:
            packet_info['proto'] = 'DNS'  # Add support for the DNS protocol

        # ICMP Protocol
        if ICMP in packet:
            packet_info['proto'] = 'ICMP'  # Add support for the ICMP protocol
            packet_info['sport'] = 'N/A'
            packet_info['dsport'] = 'N/A'
            packet_info['swin'] = 'N/A'
            packet_info['state'] = 'N/A'

        # Duration: can be the time from the first packet seen until the current one
        packet_info['dur'] = (datetime.now() - datetime.fromtimestamp(packet.time)).total_seconds()

        # Bytes
        packet_info['sbytes'] = len(packet)
        packet_info['dbytes'] = len(packet)

        # Packets (Spkts and Dpkts)
        packet_info['Spkts'] = 1
        packet_info['Dpkts'] = 1

        # Update sent and received packet variables
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst

            # Update or initialize counters for source and destination IP addresses
            for ip in [src_ip, dst_ip]:
                if ip not in packet_counts:
                    packet_counts[ip] = {'Spkts': 0, 'Dpkts': 0}

            # Increment counters for source and destination IP address
            packet_counts[src_ip]['Spkts'] += 1
            packet_counts[dst_ip]['Dpkts'] += 1

            # Update packet_info with accumulated values
            packet_info['Spkts'] = packet_counts[src_ip]['Spkts']
            packet_info['Dpkts'] = packet_counts[dst_ip]['Dpkts']

        # Number of flows with the same HTTP method
        if 'HTTPRequest' in packet:
            method = packet['HTTPRequest'].Method.decode()
            if method in http_methods_count:
                http_methods_count[method] += 1
            else:
                http_methods_count[method] = 1
            packet_info['ct_flw_http_mthd'] = http_methods_count[method]
        if packet_info['proto'] != 'N/A':
            # Write the packet to the CSV file
            write_to_csv([packet_info])

    except Exception as e:
        print(f"Error processing packet: {e}")

# Initialize packet_info outside the loop
packet_info = initialize_packet_info()

# Function to handle the interruption signal (Ctrl+C)
def handle_interrupt(signal, frame):
    print("Packet capture stopped by user.")
    sys.exit()

# Configure the interruption signal handler
signal.signal(signal.SIGINT, handle_interrupt)

# Check if the CSV file exists, and if not, add the header
if not os.path.isfile(csv_filename):
    df_header = pd.DataFrame([initialize_packet_info()])
    df_header.to_csv(csv_filename, index=False)

# Function to capture packets with Scapy
def capture_packets(interface):
    print(f"Starting packet capture on {interface}. Press Ctrl+C to stop.")
    try:
        sniff(iface=interface, prn=handle_packet, store=False)
    except KeyboardInterrupt:
        handle_interrupt(None, None)  # Call the interruption signal handler

# Check if the interface is provided as a command-line argument
if len(sys.argv) == 2:
    interface = sys.argv[1]  # Use the provided interface name
else:
    # Ask the user to enter the network interface
    interface = input("Enter the name of the interface (e.g., 'en0'): ")

# Run the packet capture with the specified interface
capture_packets(interface)

























